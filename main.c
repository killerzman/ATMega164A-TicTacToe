/*********************************************
Project : X si 0
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h"
#include "tictactoe.h"    

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

char currentLED = 1;
char currentColor = GREEN;
char currentMove = 1;

char tempLED, foundLED, row, col;

char i,j;

//ttt game board to work with
struct tttBoard tttB;

char nextAvailableLED(){
    for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){
            if(isAvailable(i,j) == TRUE){
                return (i*3 + j + 1);
            }
        }
    }
}

void setLED(char led, char value, char state){
    if(led == 1 && value == GREEN){
        LED1A = state;
    }
    if(led == 1 && value == RED){
        LED1B = state;
    }
    if(led == 2 && value == GREEN){
        LED2A = state;
    }
    if(led == 2 && value == RED){
        LED2B = state;
    }
    if(led == 3 && value == GREEN){
        LED3A = state;
    }
    if(led == 3 && value == RED){
        LED3B = state;
    }
    if(led == 4 && value == GREEN){
        LED4A = state;
    }
    if(led == 4 && value == RED){
        LED4B = state;
    }
    if(led == 5 && value == GREEN){
        LED5A = state;
    }
    if(led == 5 && value == RED){
        LED5B = state;
    }
    if(led == 6 && value == GREEN){
        LED6A = state;
    }
    if(led == 6 && value == RED){
        LED6B = state;
    }
    if(led == 7 && value == GREEN){
        LED7A = state;
    }
    if(led == 7 && value == RED){
        LED7B = state;
    }
    if(led == 8 && value == GREEN){
        LED8A = state;
    }
    if(led == 8 && value == RED){
        LED8B = state;
    }
    if(led == 9 && value == GREEN){
        LED9A = state;
    }
    if(led == 9 && value == RED){
        LED9B = state;
    }
}

void blinkLED(){
    if(currentLED == 1 && currentColor == GREEN){
        LED1A = ~LED1A;
    }
    if(currentLED == 1 && currentColor == RED){
        LED1B = ~LED1B;
    }
    if(currentLED == 2 && currentColor == GREEN){
        LED2A = ~LED2A;
    }
    if(currentLED == 2 && currentColor == RED){
        LED2B = ~LED2B;
    }
    if(currentLED == 3 && currentColor == GREEN){
        LED3A = ~LED3A;
    }
    if(currentLED == 3 && currentColor == RED){
        LED3B = ~LED3B;
    }
    if(currentLED == 4 && currentColor == GREEN){
        LED4A = ~LED4A;
    }
    if(currentLED == 4 && currentColor == RED){
        LED4B = ~LED4B;
    }
    if(currentLED == 5 && currentColor == GREEN){
        LED5A = ~LED5A;
    }
    if(currentLED == 5 && currentColor == RED){
        LED5B = ~LED5B;
    }
    if(currentLED == 6 && currentColor == GREEN){
        LED6A = ~LED6A;
    }
    if(currentLED == 6 && currentColor == RED){
        LED6B = ~LED6B;
    }
    if(currentLED == 7 && currentColor == GREEN){
        LED7A = ~LED7A;
    }
    if(currentLED == 7 && currentColor == RED){
        LED7B = ~LED7B;
    }
    if(currentLED == 8 && currentColor == GREEN){
        LED8A = ~LED8A;
    }
    if(currentLED == 8 && currentColor == RED){
        LED8B = ~LED8B;
    }
    if(currentLED == 9 && currentColor == GREEN){
        LED9A = ~LED9A;
    }
    if(currentLED == 9 && currentColor == RED){
        LED9B = ~LED9B;
    }
}

void initLEDS(){
    setLED(1,GREEN,1);
    setLED(1,RED,0);
    for(i=2; i<=9; i++){
        setLED(i,GREEN,0);
        setLED(i,RED,0);
    }
    currentLED = 1;
    currentColor = GREEN;
    currentMove = 1;
}

//reset only the game board values
void initBoard(){
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            tttB.board[i][j] = 0;
        }
    }
}

//reset only the game board winner
void initWinner(){
    tttB.winner = -1;
}

//reset everything on the game board
void initAll(){
    initLEDS();
    initBoard();
    initWinner();
}

bool isAvailable(char row, char col){
    if(tttB.board[row][col] != 0){
        return FALSE;
    }
    else return TRUE;
}

bool isBoardFull(){
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            if(isAvailable(i,j) == TRUE){
                return FALSE;
            }
        }
    }
    return TRUE;
}

//checking if the game board is in any end state
//returning the state of the game board
bool checkForEndState(){
    //initializing state with default value for no clear winner
    char state = -1;
    //check if the board is full
    if(isBoardFull() == TRUE){
        //the game is a tie
        state = 0;
        return state;
    }
    else{
        //checking rows
        for(i=0; i<3; i++){
            if(tttB.board[i][0] != 0 && tttB.board[i][0] == tttB.board[i][1] && tttB.board[i][1] == tttB.board[i][2]){
                state = tttB.board[i][0];
                return state;
            }
        }
        //checking columns
        for(j=0; j<3; j++){
            if(tttB.board[0][j] != 0 && tttB.board[0][j] == tttB.board[1][j] && tttB.board[1][j] == tttB.board[2][j]){
                state = tttB.board[0][j];
                return state;
            }
        }
        //checking first diagonal
        if(tttB.board[0][0] != 0 && tttB.board[0][0] == tttB.board[1][1] && tttB.board[1][1] == tttB.board[2][2]){
            state = tttB.board[0][0];
            return state;
        }
        //checking second diagonal
        if(tttB.board[0][2] != 0 && tttB.board[0][2] == tttB.board[1][1] && tttB.board[1][1] == tttB.board[2][0]){
            state = tttB.board[0][2];
            return state;
        }
    }
    return state;
}

void assignWinner(char state){
    tttB.winner = state;
    delay_ms(4000);
    initAll();
}

//put value in designated row and column on the game board
void put(char row, char col, char value){
    char state;
    //if the row and column haven't been occupied
    if(tttB.winner == -1 && isAvailable(row,col) == TRUE){
        //put value
        tttB.board[row][col] = value;
        setLED((row)*3 + col + 1, value, 1);
        //check for end state every successful allocation
        state = checkForEndState();
        if(state != -1){
            assignWinner(state);
        }
        else{
            currentLED = nextAvailableLED();
            if(currentColor == GREEN){
                currentColor = RED;
            }
            else if(currentColor == RED){
                currentColor = GREEN;
            }
        }
    }
}

interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
    blinkLED();
}

void checkLeft(){
    if(SW_LEFT == 0){
        delay_ms(30);
        if(SW_LEFT == 0){
            while(SW_LEFT == 0){
                wdogtrig();
            }
            setLED(currentLED, currentColor, 0);
            tempLED = currentLED;
            foundLED = FALSE;
            while(!foundLED){
                if(tempLED == 1){
                    tempLED = 9;
                }
                else{
                    tempLED --;
                }
                if(tempLED % 3 != 0){
                    row = tempLED / 3;
                    col = tempLED % 3 - 1;
                }
                else{
                    row = tempLED / 3 - 1;
                    col = 3 - 1;
                }
                if(isAvailable(row, col) == TRUE){
                    currentLED = tempLED;
                    foundLED = true;
                }    
            }
        }
    }
}

void checkRight(){
    if(SW_RIGHT == 0){
        delay_ms(30);
        if(SW_RIGHT == 0){
            while(SW_RIGHT == 0){
                wdogtrig();
            }
            setLED(currentLED, currentColor, 0);
            tempLED = currentLED;
            foundLED = FALSE;
            while(!foundLED){
                if(tempLED == 9){
                    tempLED = 1;
                }
                else{
                    tempLED ++;
                }
                if(tempLED % 3 != 0){
                    row = tempLED / 3;
                    col = tempLED % 3 - 1;
                }
                else{
                    row = tempLED / 3 - 1;
                    col = 3 - 1;
                }
                if(isAvailable(row, col) == TRUE){
                    currentLED = tempLED;
                    foundLED = true;
                }    
            }
        }
    }
}

void checkSelect(){
   if(SW_SELECT == 0){
        delay_ms(30);
        if(SW_SELECT == 0){
            while(SW_SELECT == 0){
                wdogtrig();
            }
            setLED(currentLED, currentColor, 0);
            if(currentLED % 3 != 0){
                put(currentLED / 3, currentLED % 3 - 1, currentColor);
            }
            else{
                put(currentLED / 3 - 1, 3 - 1, currentColor);
            }
        }
    }
}   

void checkButtons(){
    checkLeft();
    checkRight();
    checkSelect(); 
}

void main (void)
{       
    Init_initController();
    #asm("sei");
    initAll(); 
    while(TRUE){
        wdogtrig();
        checkButtons();
    }            
} 


